#!/bin/bash

# =========================
# Funkcja pomocy
# =========================
print_help() {
cat <<EOF
U≈ºycie: $0 [OPCJE]

Wymagane:
  --device=/≈õcie≈ºka/do/urzƒÖdzenia      Test w trybie direct (np. --device=/dev/nvme0n1)
      - lub -
  --work-file=/≈õcie≈ºka/do/pliku        Test w trybie plikowym (np. --work-file=./testfile)

Opcjonalne:
  --raport=/≈õcie≈ºka/do/raportu         ≈öcie≈ºka do pliku z raportem (domy≈õlnie ./disks_test_raport.txt)
  -h, --help                           Wy≈õwietla tƒô pomoc

Przyk≈Çady:
  $0 --device=/dev/nvme0n1 --raport=raport.txt
  $0 --work-file=./testfile
EOF
exit 0
}

# =========================
# Parsowanie argument√≥w
# =========================

DEVICE=""
WORK_FILE=""
REPORT_FILE="disks_test_raport.txt"

for arg in "$@"; do
  case $arg in
    --device=*)
      DEVICE="${arg#*=}"
      ;;
    --work-file=*)
      WORK_FILE="${arg#*=}"
      ;;
    --raport=*)
      REPORT_FILE="${arg#*=}"
      ;;
    -h|--help)
      print_help
      ;;
    *)
      echo "‚ùå Nieznany argument: $arg"
      print_help
      ;;
  esac
done

# =========================
# Walidacja parametr√≥w
# =========================

if [[ -n "$DEVICE" && -n "$WORK_FILE" ]] || [[ -z "$DEVICE" && -z "$WORK_FILE" ]]; then
  echo "‚ùå Musisz podaƒá dok≈Çadnie jeden z argument√≥w: --device=... lub --work-file=..."
  print_help
fi

# =========================
# Ustawienia i sprawdzenia
# =========================

USE_DIRECT=false
FILENAME=""
if [[ -n "$DEVICE" ]]; then
  USE_DIRECT=true
  FILENAME="$DEVICE"
  if mount | grep -q "$DEVICE"; then
    echo "‚ùå UrzƒÖdzenie $DEVICE jest zamontowane. Odmontuj je przed testem z --device."
    exit 1
  fi
else
  FILENAME="$WORK_FILE"
fi

# =========================
# Informacje systemowe
# =========================

DATE=$(date '+%Y-%m-%d %H:%M:%S')
CPU=$(lscpu | grep "Model name" | sed 's/Model name:\s*//')
RAM=$(free -h | awk '/^Mem:/ {print $2}')
BOARD=$(cat /sys/class/dmi/id/board_name 2>/dev/null || echo "Nieznana p≈Çyta")
DISK_INFO=$(lsblk -d -o NAME,VENDOR,MODEL,SIZE,TRAN | grep "$(basename $FILENAME)" || echo "Brak danych z lsblk")
SMART_INFO=$(smartctl -i "$FILENAME" 2>/dev/null)

echo "======================" | tee -a "$REPORT_FILE"
echo "üïí Data testu: $DATE" | tee -a "$REPORT_FILE"
echo "üñ•Ô∏è CPU: $CPU" | tee -a "$REPORT_FILE"
echo "üíæ RAM: $RAM" | tee -a "$REPORT_FILE"
echo "üîß P≈Çyta g≈Ç√≥wna: $BOARD" | tee -a "$REPORT_FILE"
echo "üìÄ Dysk testowany: $DISK_INFO" | tee -a "$REPORT_FILE"
echo "$SMART_INFO" | grep -E 'Model|Serial|Capacity|Interface' | tee -a "$REPORT_FILE"
echo "======================" | tee -a "$REPORT_FILE"
echo "" | tee -a "$REPORT_FILE"

FIO_FLAGS="--time_based --group_reporting --runtime=30 --size=2G --filename=$FILENAME"
[[ $USE_DIRECT == true ]] && FIO_FLAGS="$FIO_FLAGS --direct=1"

# =========================
# Funkcja testowa
# =========================
run_test() {
  NAME=$1
  DESC=$2
  PARAMS=$3
  TMP_JSON=$(mktemp)

  echo "üîπ Test: $DESC" | tee -a "$REPORT_FILE"

  fio --name="$NAME" $FIO_FLAGS $PARAMS --output-format=json --output="$TMP_JSON"

  # Parsowanie najwa≈ºniejszego wyniku
  RESULT=""
  if [[ "$NAME" == *"seq-read"* || "$NAME" == *"seq-write"* || "$NAME" == *"long-write"* ]]; then
    # Przepustowo≈õƒá (MiB/s)
    BW=$(jq 'if .jobs[0].write.bw_bytes == 0 then .jobs[0].read.bw_bytes else .jobs[0].write.bw_bytes end' "$TMP_JSON")
    MB=$(awk "BEGIN { printf \"%.2f\", $BW / 1048576 }")
    UNIT="MiB/s"
    RESULT="$MB $UNIT"
  elif [[ "$NAME" == *"randread"* || "$NAME" == *"randwrite"* ]]; then
    # IOPS
    IOPS=$(jq 'if .jobs[0].write.iops == 0 then .jobs[0].read.iops else .jobs[0].write.iops end' "$TMP_JSON")
    UNIT="IOPS"
    RESULT="$IOPS $UNIT"
  else
    RESULT="Nieznany typ testu"
  fi

  echo "‚úÖ Wynik: $DESC ‚Üí $RESULT" | tee -a "$REPORT_FILE"
  echo "" | tee -a "$REPORT_FILE"

  rm "$TMP_JSON"
}

# =========================
# Wykonywanie test√≥w
# =========================

run_test "seq-read" "Sekwencyjny odczyt 1M Q1T1" "--rw=read --bs=1M --iodepth=1 --numjobs=1"
run_test "seq-write" "Sekwencyjny zapis 1M Q1T1" "--rw=write --bs=1M --iodepth=1 --numjobs=1"
run_test "randread-q1t1" "Losowy odczyt 4K Q1T1" "--rw=randread --bs=4k --iodepth=1 --numjobs=1"
run_test "randwrite-q1t1" "Losowy zapis 4K Q1T1" "--rw=randwrite --bs=4k --iodepth=1 --numjobs=1"
run_test "randread-q32t16" "Losowy odczyt 4K Q32T16" "--rw=randread --bs=4k --iodepth=32 --numjobs=16"
run_test "randwrite-q32t16" "Losowy zapis 4K Q32T16" "--rw=randwrite --bs=4k --iodepth=32 --numjobs=16"
run_test "long-write" "Test throttlingu - ciƒÖg≈Çy zapis 60s" "--rw=write --bs=1M --iodepth=1 --numjobs=1 --runtime=60"

# =========================
# SprzƒÖtanie
# =========================

[[ $USE_DIRECT == false && -f "$WORK_FILE" ]] && rm "$WORK_FILE"

